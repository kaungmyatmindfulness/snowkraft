# Domain 5: Data Transformations - Sequences

**Exam Weight: 20-25%** | **SnowPro Core (COF-C02)**

---

## Table of Contents

1. [What Are Sequences?](#1-what-are-sequences)
2. [Creating and Managing Sequences](#2-creating-and-managing-sequences)
3. [Accessing Sequence Values](#3-accessing-sequence-values)
4. [Using Sequences as Column Defaults](#4-using-sequences-as-column-defaults)
5. [Sequences vs AUTOINCREMENT/IDENTITY](#5-sequences-vs-autoincrementidentity)
6. [Sequence Behavior and Gaps](#6-sequence-behavior-and-gaps)
7. [ORDER vs NOORDER Property](#7-order-vs-noorder-property)
8. [GETNEXTVAL Table Function](#8-getnextval-table-function)
9. [Altering Sequences](#9-altering-sequences)
10. [Best Practices](#10-best-practices)
11. [Exam Tips and Common Question Patterns](#11-exam-tips-and-common-question-patterns)
12. [Quick Reference](#12-quick-reference)

---

## 1. What Are Sequences?

### 1.1 Overview

A **sequence** is a schema-level object that generates unique numeric values across sessions and statements, including concurrent statements. Sequences are commonly used to generate surrogate keys for primary key columns.

**Key Characteristics:**
- Generates unique numbers globally (across all sessions)
- Works with concurrent statements
- Can be shared across multiple tables and columns
- Schema-level object (owned by a schema)
- Values can have gaps (not guaranteed to be contiguous)
- 64-bit integer range: -2^63 to 2^63 - 1

### 1.2 Primary Use Cases

| Use Case | Description |
|----------|-------------|
| **Primary Keys** | Generate unique identifiers for table rows |
| **Surrogate Keys** | Create artificial keys for dimension tables |
| **Order Numbers** | Generate sequential order or transaction IDs |
| **Multi-table Relationships** | Use same sequence across related tables |
| **Data Normalization** | Assign keys when normalizing denormalized data |

---

## 2. Creating and Managing Sequences

### 2.1 CREATE SEQUENCE Syntax

```sql
CREATE [ OR REPLACE ] SEQUENCE [ IF NOT EXISTS ] <name>
  [ WITH ]
  [ START [ WITH ] [ = ] <initial_value> ]
  [ INCREMENT [ BY ] [ = ] <sequence_interval> ]
  [ { ORDER | NOORDER } ]
  [ COMMENT = '<string_literal>' ]
```

**Basic Examples:**

```sql
-- Create sequence with defaults (start=1, increment=1)
CREATE SEQUENCE my_seq;

-- Create sequence starting at 1000, incrementing by 10
CREATE SEQUENCE order_seq
  START WITH 1000
  INCREMENT BY 10;

-- Create descending sequence
CREATE SEQUENCE countdown_seq
  START WITH 100
  INCREMENT BY -1;

-- Create sequence with NOORDER for better concurrency
CREATE SEQUENCE high_volume_seq
  START WITH 1
  INCREMENT BY 1
  NOORDER;
```

### 2.2 Sequence Properties

| Property | Default | Description |
|----------|---------|-------------|
| **START** | 1 | Initial value returned by first NEXTVAL call |
| **INCREMENT** | 1 | Step between consecutive values (can be negative) |
| **ORDER** | Default | Guarantees values increase across statements |
| **NOORDER** | Optional | Values not guaranteed in order (better concurrency) |

### 2.3 DROP SEQUENCE

```sql
-- Drop sequence
DROP SEQUENCE my_seq;

-- Drop if exists (no error if doesn't exist)
DROP SEQUENCE IF EXISTS my_seq;
```

**Warning:** If a sequence is used as a column default and is dropped, any INSERT/UPDATE using the default will fail.

### 2.4 SHOW and DESCRIBE

```sql
-- List all sequences in current schema
SHOW SEQUENCES;

-- List sequences matching pattern
SHOW SEQUENCES LIKE 'order%';

-- Describe sequence properties
DESC SEQUENCE my_seq;
```

---

## 3. Accessing Sequence Values

### 3.1 NEXTVAL - Get Next Value

Access the next sequence value using the `.NEXTVAL` expression:

```sql
-- Get next value in a SELECT
SELECT my_seq.NEXTVAL;

-- Use in INSERT statement
INSERT INTO orders (order_id, customer_id, amount)
VALUES (order_seq.NEXTVAL, 12345, 99.99);

-- Generate multiple values
SELECT my_seq.NEXTVAL FROM TABLE(GENERATOR(ROWCOUNT => 5));
```

### 3.2 Multiple NEXTVAL References

**Critical Exam Point:** Each reference to NEXTVAL generates a **distinct value** in Snowflake. This differs from other databases like Oracle.

```sql
-- Each NEXTVAL returns a DIFFERENT value
SELECT seq1.NEXTVAL AS a, seq1.NEXTVAL AS b FROM DUAL;
-- Result: a=1, b=2 (NOT a=1, b=1)
```

To get the **same** sequence value in multiple columns, use a nested subquery:

```sql
-- Same value in multiple columns
SELECT n, n FROM (SELECT seq1.NEXTVAL AS n);
-- Result: n=1, n=1
```

### 3.3 currval NOT Supported

**Important:** Snowflake does NOT support `currval` (current value reference). This is different from Oracle and PostgreSQL.

In other databases, `currval` retrieves the last value generated by the current session. Snowflake instead uses:
- Nested subqueries to reuse sequence values
- The GETNEXTVAL table function
- Multi-table INSERT with sequence aliases

---

## 4. Using Sequences as Column Defaults

### 4.1 Column Default Expression

Sequences are commonly used as default values for columns:

```sql
-- Create sequence
CREATE OR REPLACE SEQUENCE customer_seq;

-- Create table with sequence as default
CREATE TABLE customers (
  customer_id NUMBER DEFAULT customer_seq.NEXTVAL,
  name VARCHAR(100),
  email VARCHAR(255)
);

-- Insert without specifying customer_id (auto-generated)
INSERT INTO customers (name, email)
VALUES ('John Doe', 'john@example.com');

-- Insert with explicit DEFAULT keyword
INSERT INTO customers
VALUES (DEFAULT, 'Jane Doe', 'jane@example.com');
```

### 4.2 Shared Sequences Across Tables

One sequence can be the default for multiple columns/tables:

```sql
CREATE SEQUENCE entity_seq;

-- Same sequence for multiple tables
CREATE TABLE table_a (
  id NUMBER DEFAULT entity_seq.NEXTVAL,
  data VARCHAR(100)
);

CREATE TABLE table_b (
  id NUMBER DEFAULT entity_seq.NEXTVAL,
  info VARCHAR(100)
);
```

This ensures globally unique IDs across related tables.

---

## 5. Sequences vs AUTOINCREMENT/IDENTITY

### 5.1 AUTOINCREMENT/IDENTITY Overview

Snowflake supports AUTOINCREMENT (or its synonym IDENTITY) as a column property for auto-generating values:

```sql
CREATE TABLE orders (
  order_id NUMBER AUTOINCREMENT,
  -- or
  order_id NUMBER IDENTITY,
  -- or with start/increment
  order_id NUMBER AUTOINCREMENT START 1000 INCREMENT 10,
  amount DECIMAL(10,2)
);
```

### 5.2 Key Differences

| Feature | SEQUENCE | AUTOINCREMENT/IDENTITY |
|---------|----------|------------------------|
| **Scope** | Schema-level object | Column property (internal) |
| **Reusability** | Can be used across multiple tables/columns | Tied to single column |
| **Access** | Can query current state with SHOW SEQUENCES | Cannot directly query |
| **Flexibility** | More control over when values are generated | Automatic on INSERT |
| **Sharing** | Same sequence for related tables | Each table has its own |
| **Multi-table INSERT** | Can coordinate values | Cannot coordinate |
| **Explicit Reference** | Can reference in expressions | Only via INSERT |

### 5.3 When to Use Each

**Use SEQUENCE when:**
- You need the same unique values across multiple tables
- You need to reference the sequence value in complex queries
- You want to control when values are generated
- You're normalizing denormalized data with multi-table INSERT
- You need to coordinate IDs between fact and dimension tables

**Use AUTOINCREMENT/IDENTITY when:**
- Simple auto-incrementing column for a single table
- No need to share values across tables
- Simpler syntax is preferred
- Standard surrogate key pattern

### 5.4 Syntax Comparison

```sql
-- Using SEQUENCE
CREATE SEQUENCE order_seq START 1 INCREMENT 1;
CREATE TABLE orders (
  order_id NUMBER DEFAULT order_seq.NEXTVAL,
  amount DECIMAL(10,2)
);

-- Using AUTOINCREMENT
CREATE TABLE orders (
  order_id NUMBER AUTOINCREMENT START 1 INCREMENT 1,
  amount DECIMAL(10,2)
);

-- Using IDENTITY (synonym)
CREATE TABLE orders (
  order_id NUMBER IDENTITY(1,1),  -- (start, increment)
  amount DECIMAL(10,2)
);
```

---

## 6. Sequence Behavior and Gaps

### 6.1 Gaps Are Expected

**Critical Exam Point:** Snowflake does NOT guarantee gap-free sequences. Values are not necessarily contiguous.

**Why Gaps Occur:**
- Transaction rollbacks
- Statement failures
- Pre-allocation of sequence values
- Concurrent access from multiple sessions
- Caching for performance

```sql
-- Gaps are normal and expected
-- Values might be: 1, 2, 5, 6, 10 (gaps at 3,4,7,8,9)
```

### 6.2 Pre-calculation Behavior

Snowflake may **pre-calculate** the next sequence value as soon as the current value is used, rather than waiting until requested.

**Consequence:** An `ALTER SEQUENCE ... SET INCREMENT` might not affect the very next value - it may take effect after the second use.

```sql
-- Example showing pre-calculation effect
CREATE SEQUENCE demo_seq START 1 INCREMENT 1;

-- First few inserts: 1, 2, 3
INSERT INTO t1 (id) VALUES (demo_seq.NEXTVAL);  -- Returns 1
INSERT INTO t1 (id) VALUES (demo_seq.NEXTVAL);  -- Returns 2
INSERT INTO t1 (id) VALUES (demo_seq.NEXTVAL);  -- Returns 3

-- Alter the increment
ALTER SEQUENCE demo_seq SET INCREMENT = 10;

-- Next value might still be 4 (pre-calculated)
INSERT INTO t1 (id) VALUES (demo_seq.NEXTVAL);  -- Returns 4 (NOT 13!)

-- NOW the new increment takes effect
INSERT INTO t1 (id) VALUES (demo_seq.NEXTVAL);  -- Returns 14
```

### 6.3 Uniqueness Guarantee

**Sequence values ARE guaranteed unique** as long as:
1. The sign of the increment is not changed
2. The sequence object is the same

**Warning:** Changing increment from positive to negative (or vice versa) may produce duplicates:

```sql
-- Dangerous pattern - can cause duplicates
ALTER SEQUENCE my_seq SET INCREMENT = -1;  -- Was positive
-- Values might overlap with previously generated values
```

---

## 7. ORDER vs NOORDER Property

### 7.1 ORDER (Default)

With ORDER, sequence values are guaranteed to be increasing across statements:
- Later statements always get higher values (with positive increment)
- Provides ordering guarantee at the cost of potential contention

```sql
CREATE SEQUENCE ordered_seq ORDER;  -- Default behavior
```

**Use ORDER when:**
- You need to preserve insertion order
- Sequence values must reflect temporal ordering
- Lower concurrency requirements

### 7.2 NOORDER

With NOORDER, values are NOT guaranteed to be in increasing order:
- Better performance with concurrent INSERT operations
- Multiple sessions may get interleaved values
- Still guarantees uniqueness

```sql
CREATE SEQUENCE high_perf_seq NOORDER;
```

**Use NOORDER when:**
- High-volume concurrent inserts
- Order doesn't matter, only uniqueness
- Performance is critical

### 7.3 Comparison

| Property | Ordering Guarantee | Concurrency | Use Case |
|----------|-------------------|-------------|----------|
| **ORDER** | Yes (increasing) | Lower | Audit trails, ordered IDs |
| **NOORDER** | No | Higher | High-volume inserts |

---

## 8. GETNEXTVAL Table Function

### 8.1 Overview

GETNEXTVAL is a special table function that simplifies sequence usage in complex queries:

```sql
SELECT n, s.nextval
FROM my_table, TABLE(GETNEXTVAL(my_seq)) s;
```

### 8.2 Key Characteristics

- Returns a single-row result with a `NEXTVAL` attribute
- Must be aliased to reference the generated value
- Multiple columns can reference the same alias
- Controls where sequence values are generated in joins

### 8.3 Syntax and Usage

```sql
CREATE SEQUENCE seq1;
CREATE TABLE foo (n INT);
INSERT INTO foo VALUES (1), (2), (3);

-- Using GETNEXTVAL
SELECT n, s.nextval
FROM foo, TABLE(GETNEXTVAL(seq1)) s;

-- Result:
-- N | NEXTVAL
-- 1 | 1
-- 2 | 2
-- 3 | 3
```

### 8.4 Same Value in Multiple Columns

```sql
-- Both columns get the SAME sequence value
SELECT s.nextval AS id1, s.nextval AS id2, t.data
FROM my_table t, TABLE(GETNEXTVAL(my_seq)) s;
```

### 8.5 Multi-table INSERT with GETNEXTVAL

Useful for normalizing data:

```sql
-- Create sequences for fact and dimension tables
CREATE SEQUENCE person_seq;
CREATE SEQUENCE contact_seq;

-- Insert normalized data
INSERT ALL
  INTO people (id, name) VALUES (p_seq.nextval, name)
  INTO contacts (id, person_id, contact_info)
    VALUES (c_seq.nextval, p_seq.nextval, contact)
SELECT name, contact
FROM raw_data,
  TABLE(GETNEXTVAL(person_seq)) p_seq,
  TABLE(GETNEXTVAL(contact_seq)) c_seq;
```

---

## 9. Altering Sequences

### 9.1 ALTER SEQUENCE Syntax

```sql
ALTER SEQUENCE [ IF EXISTS ] <name>
  [ SET INCREMENT [ BY ] [ = ] <sequence_interval> ]
  [ SET { ORDER | NOORDER } ]
  [ SET COMMENT = '<string_literal>' ]
  [ UNSET COMMENT ]
```

### 9.2 What Can Be Changed

| Property | Can Alter? | Notes |
|----------|------------|-------|
| INCREMENT | Yes | May not take effect immediately |
| ORDER/NOORDER | Yes | Affects future value generation |
| COMMENT | Yes | Metadata only |
| START | No | Cannot be changed after creation |
| NAME | Yes | Via RENAME |

### 9.3 Renaming Sequences

```sql
ALTER SEQUENCE old_name RENAME TO new_name;
```

**Warning:** If sequence is used as column default, update the default:

```sql
ALTER TABLE my_table ALTER COLUMN id SET DEFAULT new_name.NEXTVAL;
```

### 9.4 Pre-calculation Effects on ALTER

Due to pre-calculation, changes may be delayed:

```sql
-- Current values: 1, 2, 3
ALTER SEQUENCE my_seq SET INCREMENT = 100;

-- Next value might be 4 (not 104) due to pre-calculation
-- Following value would be 104
```

---

## 10. Best Practices

### 10.1 Design Recommendations

1. **Use NOORDER for high-volume inserts** - Better concurrency performance
2. **Don't change increment sign** - Risk of duplicate values
3. **Account for gaps in application logic** - Never assume contiguous values
4. **Use GETNEXTVAL for complex queries** - Cleaner syntax than nested subqueries
5. **Consider AUTOINCREMENT for simple cases** - Less overhead, simpler syntax

### 10.2 Performance Considerations

| Scenario | Recommendation |
|----------|----------------|
| High-volume concurrent INSERTs | Use NOORDER |
| Need ordered IDs | Keep default ORDER |
| Single-table auto-increment | Consider AUTOINCREMENT |
| Multi-table coordination | Use shared SEQUENCE |

### 10.3 Common Patterns

**Pattern 1: Simple Primary Key**
```sql
CREATE SEQUENCE pk_seq;
CREATE TABLE items (
  id NUMBER DEFAULT pk_seq.NEXTVAL PRIMARY KEY,
  name VARCHAR(100)
);
```

**Pattern 2: Shared Sequence for Related Tables**
```sql
CREATE SEQUENCE entity_seq;
-- All entities get globally unique IDs
CREATE TABLE customers (id NUMBER DEFAULT entity_seq.NEXTVAL, ...);
CREATE TABLE vendors (id NUMBER DEFAULT entity_seq.NEXTVAL, ...);
CREATE TABLE partners (id NUMBER DEFAULT entity_seq.NEXTVAL, ...);
```

**Pattern 3: High-Volume Insert**
```sql
CREATE SEQUENCE bulk_seq NOORDER;  -- Better concurrency
```

---

## 11. Exam Tips and Common Question Patterns

### 11.1 Frequently Tested Concepts

1. **currval is NOT supported** - Snowflake does not have currval
2. **Gaps are normal** - Sequences do NOT guarantee contiguous values
3. **Multiple NEXTVAL = different values** - Each reference generates a new value
4. **Pre-calculation affects ALTER** - Changes may not be immediate
5. **NOORDER improves concurrency** - Use for high-volume scenarios
6. **Sequences can be cloned** - Part of clonable objects list

### 11.2 Common Question Patterns

**Q: What happens when you reference seq.NEXTVAL twice in the same SELECT?**
A: You get TWO DIFFERENT values (unlike Oracle where both would be the same)

**Q: Does Snowflake guarantee gap-free sequences?**
A: No, gaps can and will occur

**Q: How do you get the same sequence value in multiple columns?**
A: Use nested subquery or GETNEXTVAL table function with alias

**Q: What function replaces currval in Snowflake?**
A: Use GETNEXTVAL table function or nested subqueries

**Q: When should you use NOORDER?**
A: For high-volume concurrent INSERT operations where order doesn't matter

**Q: Can you change a sequence's START value after creation?**
A: No, START cannot be altered after the sequence is created

### 11.3 Exam Traps to Avoid

| Trap | Reality |
|------|---------|
| "Sequences guarantee no gaps" | FALSE - gaps are expected |
| "currval returns current value" | FALSE - currval not supported |
| "ALTER INCREMENT takes effect immediately" | PARTIALLY FALSE - may be delayed |
| "NEXTVAL returns same value when used twice" | FALSE - each reference is distinct |
| "AUTOINCREMENT and SEQUENCE are the same" | FALSE - different scope and flexibility |

### 11.4 Key Differentiators from Other Databases

| Feature | Snowflake | Oracle/PostgreSQL |
|---------|-----------|-------------------|
| currval | NOT supported | Supported |
| Multiple NEXTVAL | Different values | Same value |
| Gap guarantee | No guarantee | No guarantee |
| GETNEXTVAL | Supported | Not available |

---

## 12. Quick Reference

### 12.1 Essential Commands

```sql
-- Create sequence
CREATE SEQUENCE seq_name START n INCREMENT m [ORDER|NOORDER];

-- Get next value
SELECT seq_name.NEXTVAL;

-- Use as column default
CREATE TABLE t (id NUMBER DEFAULT seq_name.NEXTVAL);

-- Table function for same value in multiple places
SELECT s.nextval FROM table, TABLE(GETNEXTVAL(seq_name)) s;

-- Alter sequence
ALTER SEQUENCE seq_name SET INCREMENT = n;

-- Drop sequence
DROP SEQUENCE seq_name;

-- Show sequences
SHOW SEQUENCES;
```

### 12.2 Comparison Summary

| Feature | SEQUENCE | AUTOINCREMENT |
|---------|----------|---------------|
| Object Type | Schema-level | Column property |
| Shareable | Yes | No |
| Queryable | Yes (SHOW) | No |
| Flexibility | High | Low |
| Simplicity | Moderate | High |

### 12.3 Quick Facts for Exam

- Sequences generate unique values across sessions
- NEXTVAL increments and returns new value
- currval is NOT supported in Snowflake
- Gaps in sequences are normal and expected
- Multiple NEXTVAL references return different values
- NOORDER improves concurrent insert performance
- Pre-calculation may delay effect of ALTER SEQUENCE
- Changing increment sign may cause duplicates
- Sequences can be used as column defaults
- GETNEXTVAL table function enables value reuse
- Sequences can be cloned

---

**Related Topics:**
- Domain 5: Data Transformations - INSERT Statements
- Domain 5: Data Transformations - Multi-table INSERT
- Domain 1: Database Objects - Tables and Views
